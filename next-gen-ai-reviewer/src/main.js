const fs = require("node:fs");
const { fetchPullRequest, fetchPullFiles, postIssueComment, createReview } = require("./github");
const { loadGuidance, filterFilesByPatterns } = require("./guidanceLoader");
const { buildPrompt, buildInlineReviewPrompt, normalizeTask, TASK_LIBRARY } = require("./promptBuilder");
const { parseReviewJSON, formatReviewComments, validateReviewComments, computePositionFromPatch } = require("./reviewFormatter");
const { runChatGPT } = require("./providers/chatgpt");
const { runClaude } = require("./providers/claude");
const { runSelfHosted } = require("./providers/selfHosted");
const { generatePRDescription, runCombinedTasks, combineTasks } = require("./commandHandler");
const packageJson = require("../package.json");

function getInput(name, defaultValue = "") {
  const sanitized = name.replace(/[^a-z0-9]/gi, "_").toUpperCase();
  const dashed = name.replace(/\s+/g, "_").toUpperCase();
  const candidates = [
    `INPUT_${sanitized}`,
    `INPUT_${dashed}`,
    `INPUT_${name.toUpperCase()}`
  ];

  for (const key of candidates) {
    const rawValue = process.env[key];
    if (rawValue !== undefined && rawValue !== null && rawValue !== "") {
      return rawValue.trim();
    }
  }

  return defaultValue;
}

function readJsonFile(filePath) {
  try {
    const buffer = fs.readFileSync(filePath, "utf8");
    return JSON.parse(buffer);
  } catch {
    return null;
  }
}

function autoDetectPrNumber() {
  const directInput = getInput("pr-number") || process.env.PR_NUMBER || process.env.PR;
  if (directInput) {
    return directInput;
  }

  const eventPath = process.env.GITHUB_EVENT_PATH;
  if (eventPath && fs.existsSync(eventPath)) {
    const payload = readJsonFile(eventPath);
    const fromPayload = payload?.pull_request?.number
      || payload?.issue?.number
      || payload?.workflow_run?.pull_requests?.[0]?.number;
    if (fromPayload) {
      return fromPayload;
    }
  }

  const ref = process.env.GITHUB_REF || process.env.GITHUB_REF_NAME || "";
  const match = ref.match(/refs\/pull\/(\d+)\//);
  if (match) {
    return match[1];
  }

  return null;
}

function formatComment({ completion, repo, prNumber, reviewerName = "next-gen-ai-reviewer" }) {
  const footer = `_Automated by ${reviewerName} v${packageJson.version} (${completion.model}, ${completion.provider}) for ${repo}#${prNumber}_`;
  return `${completion.content}\n\n${footer}`;
}

async function postInlineReview({ token, owner, repo, prNumber, prMetadata: _prMetadata, completion, files, reviewerName = "next-gen-ai-reviewer" }) {
  try {
    // Parse the JSON response from AI
    const reviewData = parseReviewJSON(completion.content);

    // Format and validate comments
    const { comments, summary } = formatReviewComments(reviewData);
    const validComments = validateReviewComments(comments, files);

    console.log(`Posting ${validComments.length} inline review comments...`);

    if (validComments.length === 0) {
      console.warn("No valid comments to post. Falling back to regular comment.");
      return false;
    }

    // Format comments for GitHub API with proper position instead of line
    const formattedComments = [];
    for (const comment of validComments) {
      const file = files.find(f => f.filename === comment.path);
      if (!file || !file.patch) {
continue;
}

      const position = computePositionFromPatch(file.patch, comment.line);
      if (position === null) {
        console.warn(`Could not compute position for line ${comment.line} in ${comment.path}`);
        continue;
      }

      formattedComments.push({
        path: comment.path,
        position: position, // Use position, not line
        body: comment.body
      });
    }

    if (formattedComments.length === 0) {
      console.warn("No valid positioned comments to post. Falling back to regular comment.");
      return false;
    }

    // Get version safely
    const packageJson = require("../package.json");
    const modelInfo = completion.model && completion.provider
      ? `${completion.model}, ${completion.provider}`
      : "AI";

    // Create a review with inline comments
    const reviewBody = `## ü§ñ AI Code Review\n\n${summary}\n\n_Generated by ${reviewerName} v${packageJson.version} (${modelInfo})_`;

    await createReview({
      token,
      owner,
      repo,
      prNumber,
      body: reviewBody,
      event: "COMMENT",
      comments: formattedComments
    });

    console.log("Inline review posted successfully.");
    return true;
  } catch (error) {
    console.error("Failed to post inline review:", error.message);
    console.error("Stack trace:", error.stack);
    return false;
  }
}

async function tryProviders({ providers, prompt, task, models, selfHostedConfig, maxTokens, maxCompletionTokensMode = "auto", expectJson = false }) {
  const failures = [];

  for (const provider of providers) {
    if (provider === "chatgpt") {
      const apiKey = process.env.CHATGPT_API_KEY || process.env.OPENAI_API_KEY;
      if (!apiKey) {
        console.warn("Skipping ChatGPT provider: CHATGPT_API_KEY and OPENAI_API_KEY are both undefined.");
        failures.push("ChatGPT: missing CHATGPT_API_KEY or OPENAI_API_KEY");
        continue;
      }

      try {
        console.log(`Attempting ChatGPT provider with model ${models.chatgpt}...`);
        return await runChatGPT({ apiKey, model: models.chatgpt, prompt, task, maxTokens, maxCompletionTokensMode, expectJson });
      } catch (error) {
        console.warn(`ChatGPT provider failed: ${error.message}`);
        failures.push(`ChatGPT: ${error.message}`);
      }
    } else if (provider === "claude") {
      const apiKey = process.env.CLAUDE_API_KEY || process.env.ANTHROPIC_API_KEY;
      if (!apiKey) {
        console.warn("Skipping Claude provider: CLAUDE_API_KEY and ANTHROPIC_API_KEY are both undefined.");
        failures.push("Claude: missing CLAUDE_API_KEY or ANTHROPIC_API_KEY");
        continue;
      }

      try {
        console.log(`Attempting Claude provider with model ${models.claude}...`);
        return await runClaude({ apiKey, model: models.claude, prompt, task, maxTokens, expectJson });
      } catch (error) {
        console.warn(`Claude provider failed: ${error.message}`);
        failures.push(`Claude: ${error.message}`);
      }
    } else if (provider === "self-hosted" || provider === "selfhosted" || provider === "local") {
      const endpoint = selfHostedConfig?.endpoint || process.env.SELF_HOSTED_ENDPOINT || process.env.OPENWEBUI_API_URL;
      const apiKey = selfHostedConfig?.token || process.env.SELF_HOSTED_API_KEY || process.env.OPENWEBUI_API_KEY;
      const headerName = selfHostedConfig?.tokenHeader || process.env.SELF_HOSTED_TOKEN_HEADER;

      if (!endpoint) {
        console.warn("Skipping self-hosted provider: endpoint not configured.");
        failures.push("Self-hosted: missing self-hosted-endpoint input or SELF_HOSTED_ENDPOINT env");
        continue;
      }

      try {
        console.log(`Attempting self-hosted provider at ${endpoint}...`);
        return await runSelfHosted({
          endpoint,
          apiKey,
          model: selfHostedConfig?.model,
          prompt,
          task,
          headerName,
          maxTokens,
          expectJson
        });
      } catch (error) {
        failures.push(`Self-hosted: ${error.message}`);
      }
    }
  }

  const detail = failures.length ? failures.join(" | ") : "No providers were attempted.";
  throw new Error(`All AI providers failed. Details: ${detail}`);
}

async function run() {
  const githubToken = process.env.GITHUB_TOKEN;
  if (!githubToken) {
    throw new Error("GITHUB_TOKEN is required to fetch pull requests and post comments.");
  }

  const rawPrNumber = autoDetectPrNumber();
  if (!rawPrNumber) {
    throw new Error("Unable to determine pull request number. Provide pr-number input or set PR_NUMBER.");
  }

  const prNumber = Number(rawPrNumber);
  if (Number.isNaN(prNumber)) {
    throw new Error("pr-number must be a valid integer.");
  }

  const repository = getInput("repository") || process.env.GITHUB_REPOSITORY;
  if (!repository) {
    throw new Error("repository input is required when GITHUB_REPOSITORY is not set.");
  }

  const [owner, repo] = repository.split("/");
  if (!owner || !repo) {
    throw new Error("repository must be formatted as owner/repo.");
  }

  const task = normalizeTask(getInput("task") || "review");
  const maxFiles = Number(getInput("max-files") || process.env.MAX_FILES || "40");
  const maxDiffChars = Number(getInput("max-diff-chars") || process.env.MAX_DIFF_CHARS || "12000");
  const additionalContext = getInput("additional-context") || process.env.ADDITIONAL_CONTEXT || "";
  const maxTokens = Number(getInput("max-output-tokens") || process.env.MAX_OUTPUT_TOKENS || "16000");
  const reviewerName = getInput("reviewer-name") || process.env.REVIEWER_NAME || "next-gen-ai-reviewer";
  const providerPreference = (getInput("ai-provider") || process.env.AI_PROVIDER || "chatgpt,claude,self-hosted")
    .split(",")
    .map((value) => value.trim().toLowerCase())
    .filter(Boolean);

  const models = {
    chatgpt: getInput("chatgpt-model") || process.env.CHATGPT_MODEL || "gpt-5-mini",
    claude: getInput("claude-model") || process.env.CLAUDE_MODEL || "claude-3-5-sonnet-20241022"
  };

  const maxCompletionTokensMode = getInput("max-completion-tokens-mode") || process.env.MAX_COMPLETION_TOKENS_MODE || "auto";

  const selfHostedConfig = {
    endpoint: getInput("self-hosted-endpoint") || process.env.SELF_HOSTED_ENDPOINT || process.env.OPENWEBUI_API_URL || "",
    model: getInput("self-hosted-model") || process.env.SELF_HOSTED_MODEL || process.env.OPENWEBUI_MODEL || "local-model",
    token: getInput("self-hosted-token") || process.env.SELF_HOSTED_TOKEN || process.env.SELF_HOSTED_API_KEY || process.env.OPENWEBUI_API_KEY || "",
    tokenHeader: getInput("self-hosted-token-header") || process.env.SELF_HOSTED_TOKEN_HEADER || "Authorization"
  };

  console.log(`Fetching PR #${prNumber} from ${repository}...`);
  const prMetadata = await fetchPullRequest({ token: githubToken, owner, repo, prNumber });

  console.log("Loading repository guidance (.github)...");
  const guidance = await loadGuidance({ token: githubToken, owner, repo });

  console.log(`Fetching up to ${maxFiles} changed files...`);
  const files = await fetchPullFiles({ token: githubToken, owner, repo, prNumber, max: maxFiles });

  const { filtered, ignored } = filterFilesByPatterns(files, guidance.ignorePatterns);
  guidance.ignoredFiles = ignored.map((file) => file.filename);

  // Check if task supports inline reviews
  const inlineReviewInput = getInput("inline-review", "true");
  const useInlineReview = inlineReviewInput !== "false" && TASK_LIBRARY[task]?.inline;

  let prompt;
  if (useInlineReview) {
    console.log(`Building inline ${task} prompt with ${filtered.length} files (ignored ${ignored.length})...`);
    prompt = buildInlineReviewPrompt({
      task,
      prMetadata,
      files: filtered,
      maxDiffChars,
      additionalContext,
      guidance
    });

    if (!prompt) {
      // Fallback to regular prompt if inline not supported
      console.log("Task doesn't support inline reviews, using standard format.");
      prompt = buildPrompt({
        task,
        prMetadata,
        files: filtered,
        maxDiffChars,
        additionalContext,
        guidance
      });
    }
  } else {
    console.log(`Building ${task} prompt with ${filtered.length} files (ignored ${ignored.length})...`);
    prompt = buildPrompt({
      task,
      prMetadata,
      files: filtered,
      maxDiffChars,
      additionalContext,
      guidance
    });
  }

  // Validate that at least one real provider is configured with valid credentials
  const realProviders = providerPreference.filter(p => p !== "mock" && p !== "demo");
  const hasValidProvider = realProviders.some(provider => {
    if (provider === "chatgpt") {
      return !!(process.env.CHATGPT_API_KEY || process.env.OPENAI_API_KEY);
    }
    if (provider === "claude") {
      return !!(process.env.CLAUDE_API_KEY || process.env.ANTHROPIC_API_KEY);
    }
    if (provider === "self-hosted") {
      return !!selfHostedConfig.endpoint;
    }
    return false;
  });

  if (!hasValidProvider) {
    const providerList = realProviders.join(", ");
    const missingKeys = [];
    if (realProviders.includes("chatgpt")) {
      missingKeys.push("CHATGPT_API_KEY or OPENAI_API_KEY");
    }
    if (realProviders.includes("claude")) {
      missingKeys.push("CLAUDE_API_KEY or ANTHROPIC_API_KEY");
    }
    if (realProviders.includes("self-hosted")) {
      missingKeys.push("self-hosted-endpoint configuration");
    }
    throw new Error(
      `No valid AI provider configured. Providers requested: [${providerList}]. ` +
      `Please set one of: ${missingKeys.join(", ")} in repository secrets/environment.`
    );
  }

  // Handle special tasks: description and combined
  if (task === "description") {
    console.log(`Requesting completion via providers: ${providerPreference.join(", ")}`);
    const completion = await tryProviders({
      providers: providerPreference,
      prompt,
      task,
      models,
      selfHostedConfig,
      maxTokens,
      maxCompletionTokensMode,
      mockContext: { prMetadata, files: filtered }
    });

    const success = await generatePRDescription({
      token: githubToken,
      owner,
      repo,
      prNumber,
      completion
    });

    if (success) {
      console.log("Done. PR description successfully updated.");
      return;
    }

    console.log("Failed to update PR description, posting as comment instead...");
    const body = formatComment({ completion, repo: repository, prNumber, reviewerName });
    await postIssueComment({ token: githubToken, owner, repo, issueNumber: prNumber, body });
    console.log("Done. Description posted as comment.");
    return;
  }

  if (task === "combined") {
    const completions = await runCombinedTasks({
      tryProviders,
      buildPrompt,
      buildInlineReviewPrompt,
      prMetadata,
      files: filtered,
      maxDiffChars,
      additionalContext,
      guidance,
      providerPreference,
      models,
      selfHostedConfig,
      maxTokens,
      maxCompletionTokensMode
    });

    // Combine the task results into a single comment body
    const combinedBody = combineTasks({
      completions,
      repo: repository,
      prNumber,
      packageVersion: packageJson.version,
      reviewerName
    });

    console.log("Posting combined report as a single PR comment...");
    await postIssueComment({ token: githubToken, owner, repo, issueNumber: prNumber, body: combinedBody });
    console.log("Done. Combined report successfully posted.");
    return;
  }

  // Standard task handling (review, summary, suggestions)
  console.log(`Requesting completion via providers: ${providerPreference.join(", ")}`);
  const completion = await tryProviders({
    providers: providerPreference,
    prompt,
    task,
    models,
    selfHostedConfig,
    maxTokens,
    maxCompletionTokensMode,
    mockContext: { prMetadata, files: filtered }
  });

  // Try posting as inline review if enabled
  if (useInlineReview && prompt === buildInlineReviewPrompt({ task, prMetadata, files: filtered, maxDiffChars, additionalContext, guidance })) {
    const success = await postInlineReview({
      token: githubToken,
      owner,
      repo,
      prNumber,
      prMetadata,
      completion,
      files: filtered,
      reviewerName
    });

    if (success) {
      console.log("Done. Inline AI review successfully posted.");
      return;
    }

    console.log("Inline review failed, falling back to standard comment...");
  }

  // Fallback to regular comment
  console.log("Posting AI response as a PR comment...");
  const body = formatComment({ completion, repo: repository, prNumber, reviewerName });
  await postIssueComment({ token: githubToken, owner, repo, issueNumber: prNumber, body });

  console.log("Done. AI review successfully posted.");
}

run().catch(async (error) => {
  // Only use GitHub Actions annotations when not in test mode
  const prefix = process.env.NODE_ENV === "test" || process.env.JEST_WORKER_ID ? "" : "::error::";
  console.error(`${prefix}${error.message}`);

  // Try to post failure comment to PR
  try {
    const githubToken = process.env.GITHUB_TOKEN;
    const repository = getInput("repository") || process.env.GITHUB_REPOSITORY;
    const rawPrNumber = autoDetectPrNumber();

    if (githubToken && repository && rawPrNumber) {
      const [owner, repo] = repository.split("/");
      const prNumber = Number(rawPrNumber);
      const task = normalizeTask(getInput("task") || "review");

      const failureBody = [
        `## ‚ùå AI ${task.charAt(0).toUpperCase() + task.slice(1)} Failed`,
        "",
        `**Error:** ${error.message}`,
        "",
        "**Possible causes:**",
        "- Invalid API key or model name in repository secrets",
        "- API rate limit exceeded",
        "- Network connectivity issues",
        "- Invalid provider configuration",
        "",
        `_Failed in ${getInput("reviewer-name") || process.env.REVIEWER_NAME || "next-gen-ai-reviewer"} v${packageJson.version}_`
      ].join("\n");

      await postIssueComment({
        token: githubToken,
        owner,
        repo,
        issueNumber: prNumber,
        body: failureBody
      });

      console.log("Failure comment posted to PR.");
    }
  } catch (commentError) {
    console.error(`Failed to post failure comment: ${commentError.message}`);
  }

  process.exit(1);
});

// Export functions for testing
if (typeof module !== "undefined" && module.exports) {
  module.exports = {
    getInput,
    readJsonFile,
    autoDetectPrNumber,
    formatComment,
    postInlineReview,
    tryProviders
  };
}
