const { updatePullRequest } = require("./github");

/**
 * Generate and update PR description based on changes
 */
async function generatePRDescription({ token, owner, repo, prNumber, completion }) {
  try {
    console.log("Updating PR description with AI-generated content...");

    // Update the PR description
    await updatePullRequest({
      token,
      owner,
      repo,
      prNumber,
      body: completion.content
    });

    console.log("PR description successfully updated.");
    return true;
  } catch (error) {
    console.error("Failed to update PR description:", error.message);
    return false;
  }
}

/**
 * Run multiple tasks and combine results into a single comment
 */
async function runCombinedTasks({ tryProviders, buildPrompt, prMetadata, files, maxDiffChars, additionalContext, guidance, providerPreference, models, selfHostedConfig, maxTokens, maxCompletionTokensMode }) {
  const tasks = ["summary", "review", "suggestions"];
  const results = [];

  console.log("Running combined tasks: summary, review, suggestions...");

  for (const task of tasks) {
    try {
      console.log(`Generating ${task}...`);

      // Use inline review prompt for review task only
      const prompt = buildPrompt({
        task,
        prMetadata,
        files,
        maxDiffChars,
        additionalContext,
        guidance
      });

      const completion = await tryProviders({
        providers: providerPreference,
        prompt,
        task,
        models,
        selfHostedConfig,
        maxTokens,
        maxCompletionTokensMode,
        expectJson: task === "review", // Review needs JSON format
        mockContext: { prMetadata, files }
      });

      results.push({
        task,
        content: completion.content,
        model: completion.model,
        provider: completion.provider
      });

      console.log(`âœ“ ${task} completed`);
    } catch (error) {
      console.warn(`Failed to generate ${task}: ${error.message}`);
      results.push({
        task,
        content: `_Failed to generate ${task}: ${error.message}_`,
        model: null,
        provider: null
      });
    }
  }

  return results;
}

/**
 * Format combined results into a single markdown comment
 */
function formatCombinedReport({ results, repo, prNumber, packageVersion }) {
  const sections = [];

  // Header
  sections.push("# ðŸ“Š Complete AI Analysis Report");
  sections.push("");

  // Add each section
  const sectionTitles = {
    summary: "## ðŸ“ Summary",
    review: "## ðŸ” Code Review",
    suggestions: "## ðŸ’¡ Improvement Suggestions"
  };

  for (const result of results) {
    const title = sectionTitles[result.task] || `## ${result.task}`;
    sections.push(title);
    sections.push("");
    sections.push(result.content);
    sections.push("");
    sections.push("---");
    sections.push("");
  }

  // Footer with metadata
  const providers = results
    .filter(r => r.provider)
    .map(r => `${r.task}: ${r.provider} (${r.model})`)
    .join(", ");

  const footer = `_Generated by next-gen-ai-reviewer v${packageVersion} for ${repo}#${prNumber}${providers ? ` | ${providers}` : ""}_`;
  sections.push(footer);

  return sections.join("\n");
}

/**
 * Format combined report with inline review instead of plain review
 */
async function formatCombinedReportWithInlineReview({ summaryResult, reviewResult, suggestionsResult, files, repo, prNumber, packageVersion }) {
  const sections = [];

  // Header
  sections.push("# ðŸ“Š Complete AI Analysis Report");
  sections.push("");

  // Summary section
  if (summaryResult?.content) {
    sections.push("## ðŸ“ Summary");
    sections.push("");
    sections.push(summaryResult.content);
    sections.push("");
    sections.push("---");
    sections.push("");
  }

  // Review section - format as inline comments with file links
  if (reviewResult?.content) {
    sections.push("## ðŸ” Code Review");
    sections.push("");

    try {
      const { parseReviewJSON, formatReviewComments, validateReviewComments } = require("./reviewFormatter");

      // Parse the JSON review
      const reviewData = parseReviewJSON(reviewResult.content);
      const { comments } = formatReviewComments(reviewData);
      const validComments = validateReviewComments(comments, files);

      if (validComments.length > 0) {
        sections.push(`Found ${validComments.length} issue${validComments.length !== 1 ? "s" : ""} during code review:`);
        sections.push("");

        // Group comments by file
        const fileGroups = {};
        for (const comment of validComments) {
          if (!fileGroups[comment.path]) {
            fileGroups[comment.path] = [];
          }
          fileGroups[comment.path].push(comment);
        }

        // Format each file's comments
        for (const [filePath, fileComments] of Object.entries(fileGroups)) {
          const fileUrl = `https://github.com/${repo}/pull/${prNumber}/files#diff-${Buffer.from(filePath).toString("hex").substring(0, 40)}`;
          sections.push(`### [\`${filePath}\`](${fileUrl})`);
          sections.push("");

          for (const comment of fileComments) {
            const lineUrl = `https://github.com/${repo}/pull/${prNumber}/files#diff-${Buffer.from(filePath).toString("hex").substring(0, 40)}L${comment.line}`;
            sections.push(`**[Line ${comment.line}](${lineUrl})**`);
            sections.push("");
            sections.push(comment.body);
            sections.push("");
          }
        }
      } else {
        sections.push("No specific issues found in the code.");
        sections.push("");
      }
    } catch (error) {
      console.warn("Failed to parse review as inline comments, using plain text:", error.message);
      sections.push(reviewResult.content);
      sections.push("");
    }

    sections.push("---");
    sections.push("");
  }

  // Suggestions section
  if (suggestionsResult?.content) {
    sections.push("## ðŸ’¡ Improvement Suggestions");
    sections.push("");
    sections.push(suggestionsResult.content);
    sections.push("");
    sections.push("---");
    sections.push("");
  }

  // Footer with metadata
  const providers = [];
  if (summaryResult?.provider) providers.push(`summary: ${summaryResult.provider} (${summaryResult.model})`);
  if (reviewResult?.provider) providers.push(`review: ${reviewResult.provider} (${reviewResult.model})`);
  if (suggestionsResult?.provider) providers.push(`suggestions: ${suggestionsResult.provider} (${suggestionsResult.model})`);

  const footer = `_Generated by next-gen-ai-reviewer v${packageVersion} for ${repo}#${prNumber}${providers.length > 0 ? ` | ${providers.join(", ")}` : ""}_`;
  sections.push(footer);

  return sections.join("\n");
}

module.exports = {
  generatePRDescription,
  runCombinedTasks,
  formatCombinedReport,
  formatCombinedReportWithInlineReview
};
