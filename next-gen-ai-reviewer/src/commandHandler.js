const { updatePullRequest } = require("./github");

/**
 * Generate and update PR description based on changes
 */
async function generatePRDescription({ token, owner, repo, prNumber, completion }) {
  try {
    console.log("Updating PR description with AI-generated content...");

    // Update the PR description
    await updatePullRequest({
      token,
      owner,
      repo,
      prNumber,
      body: completion.content
    });

    console.log("PR description successfully updated.");
    return true;
  } catch (error) {
    console.error("Failed to update PR description:", error.message);
    return false;
  }
}

/**
 * Run multiple tasks and combine results into a single comment
 */
async function runCombinedTasks({ tryProviders, buildPrompt, prMetadata, files, maxDiffChars, additionalContext, guidance, providerPreference, models, selfHostedConfig, maxTokens, maxCompletionTokensMode }) {
  const tasks = ["summary", "review", "suggestions"];
  const results = [];

  console.log("Running combined tasks: summary, review, suggestions...");

  for (const task of tasks) {
    try {
      console.log(`Generating ${task}...`);

      const prompt = buildPrompt({
        task,
        prMetadata,
        files,
        maxDiffChars,
        additionalContext,
        guidance
      });

      const completion = await tryProviders({
        providers: providerPreference,
        prompt,
        task,
        models,
        selfHostedConfig,
        maxTokens,
        maxCompletionTokensMode,
        mockContext: { prMetadata, files }
      });

      results.push({
        task,
        content: completion.content,
        model: completion.model,
        provider: completion.provider
      });

      console.log(`âœ“ ${task} completed`);
    } catch (error) {
      console.warn(`Failed to generate ${task}: ${error.message}`);
      results.push({
        task,
        content: `_Failed to generate ${task}: ${error.message}_`,
        model: null,
        provider: null
      });
    }
  }

  return results;
}

/**
 * Format combined results into a single markdown comment
 */
function formatCombinedReport({ results, repo, prNumber, packageVersion }) {
  const sections = [];

  // Header
  sections.push("# ðŸ“Š Complete AI Analysis Report");
  sections.push("");

  // Add each section
  const sectionTitles = {
    summary: "## ðŸ“ Summary",
    review: "## ðŸ” Code Review",
    suggestions: "## ðŸ’¡ Improvement Suggestions"
  };

  for (const result of results) {
    const title = sectionTitles[result.task] || `## ${result.task}`;
    sections.push(title);
    sections.push("");
    sections.push(result.content);
    sections.push("");
    sections.push("---");
    sections.push("");
  }

  // Footer with metadata
  const providers = results
    .filter(r => r.provider)
    .map(r => `${r.task}: ${r.provider} (${r.model})`)
    .join(", ");

  const footer = `_Generated by next-gen-ai-reviewer v${packageVersion} for ${repo}#${prNumber}${providers ? ` | ${providers}` : ""}_`;
  sections.push(footer);

  return sections.join("\n");
}

module.exports = {
  generatePRDescription,
  runCombinedTasks,
  formatCombinedReport
};
